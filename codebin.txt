cl = contig_data.contig_length;
        self.window_length = window_length;
        self.step_size = step_size;
        self.contig_coverage = {};  # associates contigs with their windows' coverages.
        self.contig_window_starting_points = {}
        for contig_id in cl:
            window_coverage = [];
            window_starting_points = [];
            current_pos = 1;
            while current_pos + window_length - 1 <= cl[contig_id]:
                window_starting_points.append(current_pos);
                curr_window_coverage = self.__calcwindowcoverage__(samfile, contig_id, current_pos, window_length)
                window_coverage.append(curr_window_coverage);
                current_pos += step_size;
            # Do I have anything remaining in the contig?
            if current_pos < cl[contig_id]:
                window_starting_points.append(current_pos);
                last_window_coverage = self.__calcwindowcoverage__(samfile, contig_id, current_pos, cl[contig_id] - current_pos + 1)
                window_coverage.append(last_window_coverage);

            self.contig_coverage[contig_id] = window_coverage;
            self.contig_window_starting_points[contig_id] = window_starting_points;

    # Calculate the coverage over an entire window
    def __calcwindowcoverage__(self, samfile, contig_id, current_pos, window_length):
        alignments = samfile.coverage(contig_id, current_pos, window_length);
        total_window_coverage = 0;
        for aln in alignments:
            starting_overlap_index = max(aln.start(), current_pos);
            ending_overlap_index = min(aln.end(), current_pos + window_length - 1);
            total_window_coverage += (1.0 * (ending_overlap_index - starting_overlap_index + 1)) / window_length;
        return total_window_coverage;